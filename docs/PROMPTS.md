# Using Embedded Prompts in Tasks

scaffoldfy supports embedding prompts directly in your task definitions. This allows you to collect user input dynamically and use those values in your task configurations.

## Overview

Prompts enable you to:

- Collect custom user input when running initialization
- Support different input types (text, numbers, selections, confirmations, passwords)
- Define default values and validation rules
- Execute commands to generate dynamic default values (e.g., git branch, npm version, node version)
- Use prompt values in task configs via template interpolation
- **Create global variables** available across all tasks using `"global": true`

## Global Prompts

**Important:** scaffoldfy no longer has built-in variables. Instead, use prompts with `"global": true` to create variables that are available to all tasks.

### Example: Creating Global Configuration Variables

```json
{
  "id": "setup-globals",
  "name": "Setup Global Variables",
  "description": "Collect project-wide configuration",
  "required": true,
  "enabled": true,
  "type": "update-json",
  "prompts": [
    {
      "id": "projectName",
      "type": "input",
      "message": "Project name",
      "global": true,
      "required": true
    },
    {
      "id": "author",
      "type": "input",
      "message": "Author name",
      "global": true,
      "default": {
        "type": "exec",
        "value": "git config --get user.name"
      }
    },
    {
      "id": "repoUrl",
      "type": "input",
      "message": "Repository URL",
      "global": true,
      "default": {
        "type": "exec",
        "value": "git config --get remote.origin.url"
      }
    }
  ],
  "config": {
    "file": "package.json",
    "updates": {
      "name": "{{projectName}}",
      "author": "{{author}}",
      "repository": {
        "type": "git",
        "url": "{{repoUrl}}"
      }
    }
  }
}
```

In this example:

- All prompts have `"global": true`, making their values available to all subsequent tasks
- The values can be used in any task using `{{projectName}}`, `{{author}}`, `{{repoUrl}}`
- You can also create tasks with only global prompts and no config (just to collect variables)

## Prompt Types

### 1. Input Prompt

Collect text input from the user.

```json
{
  "id": "projectName",
  "type": "input",
  "message": "What is your project name?",
  "default": "my-project",
  "required": true,
  "placeholder": "Enter project name"
}
```

### 2. Password Prompt

Securely collect sensitive information (masked input).

```json
{
  "id": "apiKey",
  "type": "password",
  "message": "Enter your API key",
  "required": true
}
```

### 3. Number Prompt

Collect numeric input with optional min/max constraints.

```json
{
  "id": "port",
  "type": "number",
  "message": "Server port?",
  "default": 3000,
  "min": 1024,
  "max": 65535
}
```

### 4. Select Prompt

Present a list of choices to the user.

```json
{
  "id": "framework",
  "type": "select",
  "message": "Select your framework",
  "choices": [
    { "name": "React", "value": "react" },
    { "name": "Vue", "value": "vue" },
    { "name": "Svelte", "value": "svelte" }
  ],
  "default": "react"
}
```

### 5. Confirm Prompt

Ask a yes/no question.

```json
{
  "id": "includeTests",
  "type": "confirm",
  "message": "Include test setup?",
  "default": true
}
```

## Executable Default Values

Default values can be either static values or dynamically generated by executing shell commands. This is useful for providing context-aware defaults based on the current environment.

### Static Default Values

The traditional way to define defaults:

```json
{
  "id": "projectName",
  "type": "input",
  "message": "Project name",
  "default": "my-project"
}
```

### Executable Default Values

Execute a command to generate the default value:

```json
{
  "id": "projectName",
  "type": "input",
  "message": "Project name",
  "default": {
    "type": "exec",
    "value": "basename $(pwd)"
  }
}
```

### How It Works

1. **Parallel Execution**: All executable defaults are resolved in parallel before any prompts are shown
2. **Auto-parsing**: Command output is automatically trimmed and parsed as:
   - **JSON** if output starts with `{` or `[`
   - **Number** if output matches a numeric pattern
   - **Boolean** if output is `"true"` or `"false"`
   - **String** otherwise
3. **Timeout**: Commands have a 10-second timeout
4. **Error Handling**: If a command fails, the default value becomes `undefined` (no default)

### Common Use Cases

#### Git Information

Get the current git branch:

```json
{
  "id": "branchName",
  "type": "input",
  "message": "Branch name",
  "default": {
    "type": "exec",
    "value": "git branch --show-current"
  }
}
```

Get the git remote URL:

```json
{
  "id": "repoUrl",
  "type": "input",
  "message": "Repository URL",
  "default": {
    "type": "exec",
    "value": "git config --get remote.origin.url"
  }
}
```

Get the current git user name:

```json
{
  "id": "authorName",
  "type": "input",
  "message": "Author name",
  "default": {
    "type": "exec",
    "value": "git config user.name"
  }
}
```

#### Node.js and Package Manager Info

Detect the Node.js version:

```json
{
  "id": "nodeVersion",
  "type": "input",
  "message": "Node.js version",
  "default": {
    "type": "exec",
    "value": "node --version"
  }
}
```

Detect which package manager is available:

```json
{
  "id": "packageManager",
  "type": "select",
  "message": "Package manager",
  "choices": [
    { "name": "npm", "value": "npm" },
    { "name": "pnpm", "value": "pnpm" },
    { "name": "yarn", "value": "yarn" }
  ],
  "default": {
    "type": "exec",
    "value": "command -v pnpm > /dev/null && echo 'pnpm' || (command -v yarn > /dev/null && echo 'yarn' || echo 'npm')"
  }
}
```

#### Environment Detection

Check if running in CI:

```json
{
  "id": "isCI",
  "type": "confirm",
  "message": "Running in CI?",
  "default": {
    "type": "exec",
    "value": "test -n \"$CI\" && echo 'true' || echo 'false'"
  }
}
```

Check if a directory exists:

```json
{
  "id": "hasTests",
  "type": "confirm",
  "message": "Include tests?",
  "default": {
    "type": "exec",
    "value": "test -d tests && echo 'true' || echo 'false'"
  }
}
```

Get the current directory name:

```json
{
  "id": "projectName",
  "type": "input",
  "message": "Project name",
  "default": {
    "type": "exec",
    "value": "basename $(pwd)"
  }
}
```

#### System Information

Get the operating system:

```json
{
  "id": "os",
  "type": "select",
  "message": "Operating system",
  "choices": [
    { "name": "Linux", "value": "linux" },
    { "name": "macOS", "value": "darwin" },
    { "name": "Windows", "value": "win32" }
  ],
  "default": {
    "type": "exec",
    "value": "node -p \"process.platform\""
  }
}
```

#### Number Prompts with Executable Defaults

Find an available port:

```json
{
  "id": "port",
  "type": "number",
  "message": "Development server port",
  "min": 1024,
  "max": 65535,
  "default": {
    "type": "exec",
    "value": "node -e \"require('net').createServer().listen(0, () => { console.log(require('net').createServer().address().port); process.exit(); })\""
  }
}
```

Or use a simpler approach:

```json
{
  "id": "port",
  "type": "number",
  "message": "Development server port",
  "default": {
    "type": "exec",
    "value": "echo 3000"
  }
}
```

### Explicit Value Type

You can also explicitly mark a static value using the `value` type:

```json
{
  "id": "projectName",
  "type": "input",
  "message": "Project name",
  "default": {
    "type": "value",
    "value": "my-project"
  }
}
```

This is equivalent to:

```json
{
  "id": "projectName",
  "type": "input",
  "message": "Project name",
  "default": "my-project"
}
```

### Best Practices for Executable Defaults

1. **Keep commands simple**: Complex commands are harder to debug
2. **Handle errors gracefully**: Commands may fail; ensure your prompts work without defaults
3. **Use platform-agnostic commands when possible**: Consider cross-platform compatibility
4. **Test your commands**: Verify they work in different environments
5. **Provide static fallbacks**: Consider having a static default if the command fails
6. **Be mindful of security**: Avoid executing untrusted input
7. **Use timeouts wisely**: Commands timeout after 10 seconds; keep them fast

### Windows Compatibility

For cross-platform compatibility, prefer using Node.js commands or Git commands over shell-specific syntax:

```json
{
  "id": "projectName",
  "type": "input",
  "message": "Project name",
  "default": {
    "type": "exec",
    "value": "node -p \"require('path').basename(process.cwd())\""
  }
}
```

This works on Windows, macOS, and Linux without modification.

## Complete Example

Here's a complete example showing how to use prompts with executable defaults in `template-tasks.json`:

```json
{
  "tasks": [
    {
      "id": "setup-project",
      "name": "Setup Project",
      "description": "Configure project with custom settings",
      "required": true,
      "enabled": true,
      "type": "update-json",
      "prompts": [
        {
          "id": "appName",
          "type": "input",
          "message": "Application name",
          "default": {
            "type": "exec",
            "value": "node -p \"require('path').basename(process.cwd())\""
          },
          "required": true
        },
        {
          "id": "authorName",
          "type": "input",
          "message": "Author name",
          "default": {
            "type": "exec",
            "value": "git config user.name"
          }
        },
        {
          "id": "authorEmail",
          "type": "input",
          "message": "Author email",
          "default": {
            "type": "exec",
            "value": "git config user.email"
          }
        },
        {
          "id": "useTypeScript",
          "type": "confirm",
          "message": "Use TypeScript?",
          "default": true
        },
        {
          "id": "packageManager",
          "type": "select",
          "message": "Package manager",
          "choices": [
            { "name": "npm", "value": "npm" },
            { "name": "pnpm", "value": "pnpm" },
            { "name": "yarn", "value": "yarn" }
          ],
          "default": {
            "type": "exec",
            "value": "command -v pnpm > /dev/null && echo 'pnpm' || echo 'npm'"
          }
        },
        {
          "id": "port",
          "type": "number",
          "message": "Development server port",
          "default": 3000,
          "min": 1024,
          "max": 65535
        }
      ],
      "config": {
        "file": "package.json",
        "updates": {
          "name": "{{appName}}",
          "author": "{{authorName}} <{{authorEmail}}>",
          "scripts": {
            "dev": "vite --port {{port}}"
          }
        }
      }
    },
    {
      "id": "setup-env",
      "name": "Setup Environment",
      "description": "Create .env file with API credentials",
      "required": false,
      "enabled": true,
      "type": "template",
      "prompts": [
        {
          "id": "apiUrl",
          "type": "input",
          "message": "API URL",
          "default": "https://api.example.com"
        },
        {
          "id": "apiSecret",
          "type": "password",
          "message": "API Secret Key",
          "required": true
        }
      ],
      "config": {
        "file": ".env",
        "template": "API_URL={{apiUrl}}\\nAPI_SECRET={{apiSecret}}\\n"
      }
    }
  ]
}
```

## Global Prompts

You can mark prompts as **global** by setting `"global": true`. Global prompts are collected once at the beginning and their values are available to **all tasks**, not just the task where they're defined.

### When to Use Global Prompts

Use global prompts when:

- Multiple tasks need the same value (e.g., project name, version, author)
- You want to collect common information upfront
- You want to avoid asking the user the same question multiple times

### Example: Global Prompts

```json
{
  "tasks": [
    {
      "id": "update-package-json",
      "name": "Update package.json",
      "description": "Set project metadata",
      "required": true,
      "enabled": true,
      "type": "update-json",
      "prompts": [
        {
          "id": "projectName",
          "type": "input",
          "message": "What is your project name?",
          "global": true,
          "required": true
        },
        {
          "id": "projectVersion",
          "type": "input",
          "message": "Initial version",
          "default": "0.1.0",
          "global": true
        }
      ],
      "config": {
        "file": "package.json",
        "updates": {
          "name": "{{projectName}}",
          "version": "{{projectVersion}}"
        }
      }
    },
    {
      "id": "create-readme",
      "name": "Create README",
      "description": "Generate README file",
      "required": true,
      "enabled": true,
      "type": "template",
      "config": {
        "file": "README.md",
        "template": "# {{projectName}}\\n\\nVersion: {{projectVersion}}"
      }
    },
    {
      "id": "setup-config",
      "name": "Setup Config",
      "description": "Create config file",
      "required": false,
      "enabled": true,
      "type": "update-json",
      "prompts": [
        {
          "id": "enableDebug",
          "type": "confirm",
          "message": "Enable debug mode?",
          "default": false
        }
      ],
      "config": {
        "file": "config.json",
        "updates": {
          "name": "{{projectName}}",
          "debug": "{{enableDebug}}"
        }
      }
    }
  ]
}
```

In this example:

- `projectName` and `projectVersion` are marked as **global**
- They are prompted once when the first task runs
- Both values can be used in **all three tasks** (update-package-json, create-readme, setup-config)
- `enableDebug` is **task-specific** and only available to the setup-config task

### Prompt Collection Order

When you run initialization:

1. **Global prompts** are collected first (shown once, even if defined in multiple tasks)
2. **Task-specific prompts** are collected afterwards

This ensures users provide common information upfront before task-specific details.

## Using Prompt Values

Prompt values are automatically merged into the configuration object and can be used anywhere template interpolation is supported:

- `{{promptId}}` - Access prompt values in config via template interpolation
- Works in all task types (update-json, template, regex-replace, etc.)
- Values are available alongside built-in config values (projectName, author, etc.)
- **Global prompts** are available to all tasks
- **Task-specific prompts** are only available within their task

### Using Prompt Values in Conditions

Prompt values can also be used directly in condition expressions for `delete` tasks:

```json
{
  "id": "handle-example-packages",
  "name": "Handle example packages",
  "description": "Prompt user about keeping example packages and remove if not wanted",
  "required": false,
  "enabled": true,
  "type": "delete",
  "prompts": [
    {
      "id": "keepExamplePackages",
      "type": "confirm",
      "message": "Keep example packages? (helpful for reference)",
      "default": true
    }
  ],
  "config": {
    "condition": "!keepExamplePackages",
    "paths": ["packages/example-package"]
  }
}
```

In this example:

- When the user answers **"No" (false)** to the confirm prompt, `keepExamplePackages` is `false`
- The condition `!keepExamplePackages` evaluates to `true`, so the directories are deleted
- When the user answers **"Yes" (true)**, `keepExamplePackages` is `true`
- The condition `!keepExamplePackages` evaluates to `false`, so the directories are kept

You can use any JavaScript expression in conditions, including:

- Boolean values: `keepExamplePackages`, `!includeTests`
- Comparisons: `framework === "react"`, `port > 3000`
- String methods: `projectName.startsWith("my-")`
- Logical operators: `useTypeScript && includeTests`

## Validation Rules

Prompts are validated automatically:

- **ID**: Must contain only alphanumeric characters, underscores, and hyphens
- **ID uniqueness**: All prompt IDs across all tasks must be unique (duplicates are only allowed if all instances are marked as global with the same definition)
- **Global vs task-specific conflict**: A prompt ID cannot be used as both global and task-specific
- **Required**: If `required: true`, empty values are rejected
- **Number min/max**: Values must be within specified range
- **Select choices**: At least one choice must be provided
- **Executable defaults**: Commands that fail will result in no default value (prompt shown without a default)

## TypeScript Support

For TypeScript task files (`template-tasks.ts`), you can use typed prompt definitions:

```typescript
import type { TaskDefinition } from '@pixpilot/scaffoldfy';

export const tasks: TaskDefinition[] = [
  {
    id: 'setup',
    name: 'Setup',
    description: 'Project setup',
    required: true,
    enabled: true,
    type: 'update-json',
    prompts: [
      {
        id: 'projectName',
        type: 'input',
        message: 'Project name?',
        required: true,
      },
    ],
    config: {
      file: 'package.json',
      updates: {
        name: '{{projectName}}',
      },
    },
  },
];
```

## Best Practices

1. **Use descriptive IDs**: Choose clear, semantic IDs like `apiKey` instead of `key1`
2. **Provide defaults**: Always provide sensible defaults when possible
3. **Use executable defaults for context**: Let the environment suggest intelligent defaults (e.g., git user name, current directory)
4. **Mark shared prompts as global**: If multiple tasks need the same value, mark the prompt as `"global": true`
5. **Group related prompts**: Put prompts in the task where they're primarily used
6. **Validate inputs**: Use `required`, `min`, `max` to ensure valid data
7. **Keep it simple**: Don't overwhelm users with too many prompts
8. **Collect global prompts first**: Define global prompts in your first task so they're collected early
9. **Test executable defaults**: Ensure commands work across different platforms
10. **Handle command failures gracefully**: Don't rely solely on executable defaults for required prompts

## CLI Usage

Run initialization with prompts:

```bash
# Using JSON file (default)
scaffoldfy --tasks-file ./template-tasks.json

# Using TypeScript file
scaffoldfy --tasks-ts ./template-tasks.ts

# Dry run to preview
scaffoldfy --dry-run
```

The CLI will automatically detect prompts in your tasks and collect user input before executing the tasks.

